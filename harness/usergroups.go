package harness

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/fs"
	"os"
	"text/template"

	"github.com/aleksa11010/harness-api-wrapper/templates"
)

// Generated by https://quicktype.io

type UserGroups struct {
	Status        string        `json:"status"`
	Data          UserGroupData `json:"data"`
	MetaData      interface{}   `json:"metaData"`
	CorrelationID string        `json:"correlationId"`
}

type UserGroupsFiltered struct {
	Status        string             `json:"status"`
	Data          []UserGroupContent `json:"data"`
	MetaData      interface{}        `json:"metaData"`
	CorrelationID string             `json:"correlationId"`
}

type UserGroupData struct {
	TotalPages    int64              `json:"totalPages"`
	TotalItems    int64              `json:"totalItems"`
	PageItemCount int64              `json:"pageItemCount"`
	PageSize      int64              `json:"pageSize"`
	Content       []UserGroupContent `json:"content"`
	PageIndex     int64              `json:"pageIndex"`
	Empty         bool               `json:"empty"`
	PageToken     interface{}        `json:"pageToken"`
}

type UserGroupContent struct {
	AccountIdentifier   UserGroupAccountIdentifier `json:"accountIdentifier"`
	Identifier          string                     `json:"identifier"`
	Name                string                     `json:"name"`
	Users               []string                   `json:"users"`
	NotificationConfigs []interface{}              `json:"notificationConfigs"`
	ExternallyManaged   bool                       `json:"externallyManaged"`
	Description         string                     `json:"description"`
	Tags                interface{}                `json:"tags"`
	HarnessManaged      bool                       `json:"harnessManaged"`
	SsoLinked           bool                       `json:"ssoLinked"`
}

type UserGroupAccountIdentifier string

type UserGroupAPI interface {
	GetAllUserGroups(format string, account string) (Entities, error)
	GetAdminUsers(format string, account string) (Entities, error)
}

func (u UserGroups) FormatUserGroups() error {

	content := make([]json.RawMessage, 0)
	for _, userGroup := range u.Data.Content {
		group, err := json.Marshal(userGroup)
		if err != nil {
			fmt.Printf("error marshalling user group: %s", err)
		}
		content = append(content, json.RawMessage(group))
	}

	reportData, err := json.Marshal(content)
	if err != nil {
		fmt.Println("Unable to marshal json", err)
		return err
	}
	err = createUserGroupReport(reportData, "usergroups", "User Groups")
	if err != nil {
		fmt.Println("Unable to create a HTML output :", err)
		return err
	}
	return nil
}

func (u UserGroupsFiltered) FormatUserGroupsFiltered() error {

	content := make([]json.RawMessage, 0)
	for _, userGroup := range u.Data {
		group, err := json.Marshal(userGroup)
		if err != nil {
			fmt.Printf("error marshalling user group: %s", err)
		}
		content = append(content, json.RawMessage(group))
	}

	reportData, err := json.Marshal(content)
	if err != nil {
		fmt.Println("Unable to marshal json", err)
		return err
	}
	err = createUserGroupReport(reportData, "adminusers", "User Groups")
	if err != nil {
		fmt.Println("Unable to create a HTML output :", err)
		return err
	}
	return nil
}

func (u UserGroupsFiltered) ListAdminUsers(admins map[string]UsersContent) error {
	content := make([]json.RawMessage, 0)
	for _, userGroup := range u.Data {
		for _, u := range userGroup.Users {
			if admins[u].Email == "" {
				continue
			}
			user, err := json.Marshal(admins[u])
			if err != nil {
				fmt.Printf("error marshalling user group: %s", err)
			}
			content = append(content, json.RawMessage(user))
		}
	}

	reportData, err := json.Marshal(content)
	if err != nil {
		fmt.Println("Unable to marshal json", err)
		return err
	}

	err = createUserGroupReport(reportData, "adminusers", "Admins")
	if err != nil {
		fmt.Println("Unable to create a HTML output :", err)
	}
	return nil
}

func createUserGroupReport(content []byte, filename string, header string) error {
	type ReportData struct {
		Header  string
		Content string
	}

	type IndexData struct {
		AdminUsers bool
	}

	reportData := ReportData{
		Header:  header,
		Content: string(content),
	}

	userGroupsTemplate, err := fs.ReadFile(templates.EmbeddedFiles, "report.html")
	if err != nil {
		fmt.Printf("error reading user groups template: %s", err)
	}

	indexTemplate, err := fs.ReadFile(templates.EmbeddedFiles, "index.html")
	if err != nil {
		fmt.Printf("error reading index template: %s", err)
	}

	t, err := template.New("usergroups").Parse(string(userGroupsTemplate))
	if err != nil {
		fmt.Printf("error parsing user groups template: %s", err)
		return err
	}

	it, err := template.New("index").Parse(string(indexTemplate))
	if err != nil {
		fmt.Printf("error parsing index template: %s", err)
		return err
	}

	var output bytes.Buffer

	err = it.Execute(&output, IndexData{
		AdminUsers: true,
	})
	if err != nil {
		fmt.Println(err)
		return err
	}

	indexFile, err := os.OpenFile("./report/index.html", os.O_TRUNC|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}
	defer indexFile.Close()

	_, err = indexFile.Write(output.Bytes())
	if err != nil {
		panic(err)
	}
	output.Reset()

	err = t.Execute(&output, reportData)
	if err != nil {
		fmt.Println(err)
		return err
	}

	if _, err := os.Stat("report"); os.IsNotExist(err) {
		err = os.Mkdir("report", 0755)
		if err != nil {
			panic("Unable to create directory")
		}
	}
	if _, err := os.Stat("report/data"); os.IsNotExist(err) {
		err = os.Mkdir("report/data", 0755)
		if err != nil {
			panic("Unable to create directory")
		}
	}

	file, err := os.OpenFile(fmt.Sprintf("./report/data/%s.html", filename), os.O_TRUNC|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	_, err = file.Write(output.Bytes())
	if err != nil {
		panic(err)
	}

	return nil
}
